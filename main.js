/*'number' + 23 + 32 //результат: number2332, якщо один з операторів рядок - відбувається конкатенація, 
//23 перетворюється на рядок та зливається з number, теж саме відбувається з 32: "number23"+"32"

41 + 1 + 'number'//результат: 42number, 41+1 - відбувається математична операція, 
//потім 42 та "number" - відбувається конкатенація, 42 перетворюється на рядок

null + 1 // результат: 1, null перетворюється на 0, відбувається математична операція 0 + 1

'five' + + 'two' //результат: fiveNaN, + перед рядком перетворює рядок на число, але "two" не можна перетворити на число,
// тому результатом є NaN, потім відбувається конкатенація "five" + "Nan"

2 && 7 // результат: 7, логічне І повертає true якщо обидва операнди true, так як 2 та 7 є true,
 логічне І поверне останнє істинне значення

 +'40' + +'2'// результат: 42, + перед рядком перетворює рядок на число, "40" та "2" можна перетворити на числа 40 та 2,
 //тому відбувається математична операція 40+2

 '10' - 5 === 6 //результат: false, "10" в цьому виразі перетворюється на число 10, відбувається математична операція
 10-5=5, далі === (строго дорівнює) 6, 5 не дорівнює 6, тому результат false

 true + false //результат: 1, true перетворюється на 1, false перетворюється на 0,
 //відбувається математична операція 1+0

 '4px' - 3 //результат: Nan, для проведення математичної операції у даному випадку перетворюємо "4рх" на число, 
 //але 4рх не є числом тому перетворюється на Nan, будь-яка операція з Nan - Nan.

'4' - 3 //результат: 1, схожий на попередній випадок, але "4" для проведення математичної операції можна перетворити на число 4,
//тому в результаті маємо вираз 4-3

'2' + 3 ** 2 // результат: 29, за пріоритетом математичних операторів піднесення до степеня виконується першим у цьому виразі,
// 3 в степені 2 дорівнює 9, отримуємо вираз "2" + 9, в цьому випадку відбувається конкатенація ("2" + "9"), тому результат 29

12 / '6' // результат: 2, для проведення операції ділення, '6' перетворюємо на число, 12/6 дорівнює 2

23 + 42 + 'number' //результат: 65number, йдемо по порядку 23+42 = 65, 
65 + 'number' відбувається конкатенація ('65' + 'number')

'10' + (5 === 6) // результат: 10false, те що в дужках пріорітет, тому розглянемо вираз 5===6, 5 не строго дорівнює 6
//тому результат в дужках false, отримуємо '10' + false, відбувається конкатенція ('10' + 'false')

'number' + 15 + 3 // результат: number153, відбувається конкатенція ('number' + '15'), потім ще раз конкатенація ('number15' + '3')

undefined + 1 //результат: Nan, undefined у числовому значенні є Nan, будь-яка операція з Nan - Nan

'true' == true //результат: false, оператор рівності приводить обидва операнди до одного значення, true перетворюється на 1,
// 'true' перетворюється на Nan, Nan не дорівнює 1

false == 'false' //результат: false, схожий приклад на попередній, false перетворюється на 0, 'false' перетворюється на Nan,
//Nan не дорівнює 0

null == '' // результат: false, null при порівнянні за допомогою == не перетворюється на інший тип та дорівнює лише самому собі

3 ** (9 / 3) // результат: 27, пріорітетом є вираз в дужках, тому спочатку 9/3 = 3
//далі 3 в степені 3 дорівнює 27

!!'false' == !!'true' //результат: true, не порожні рядки є істинними значеннями, тобто true
// знак заперечення перетворює значення на булевий тип та інвертує його, тобто !'false' = false, !'true' = false
//ще один знак заперечення інвертує значення знову, !!'false' = true, !!'true' = true
//true == true

0 || '0' && 1 //результат: 1, оператор логічне І має вищий пріорітет, тому спочатку виконуємо вираз '0' && 1
// '0' є істинним, бо будь-який непорожній рядок є істинним, логічне І повертає істину, якщо обидва операнди істина, 
//тут результатом є останнє істинне значення, тобто 1
//логічне або повертає істину, якщо один з операндів істина, тому повертає перше істинне значення, яке зустрічає - 1

1 < 2 < 3 //результат: true, спочатку перевіряємо 1 < 2, це true, далі перевіряємо вже true < 3, в даному випадку перетворюємо
// true на число 1 для порівняння, 1 < 3 є істиною

'foo'+ + +'bar' // результат: fooNan, +'bar' спробує перетворити вираз на число, але не можемо цього зробити,
//тому результат Nan, + Nan спробує перетворити Nan на число, але Nan вже є числом, тому залишається як є, Nan 
//отримуємо 'foo' + Nan і відбувається конкатенація

3 ** 2 / 3 //результат: 3, спочатку рахуємо 3 в степені 2, дорівнює 9
//отримуємо 9/3, дорівнює 3

1 < 2 > 3 // результат: false, обчислюємо спочатку 1 < 2, результат true,
//потім обчислюємо вже true > 3, перетворюємо true на число, виходить 1 > 3, що не є істиною

(+null == false) < 1 //результат false, обчислюємо вираз у дужках, +null перетворює null на число 0, 
0 == false дає результат true, отримуємо true < 1, для обчислення перетворюється true на число 1, 1 < 1 не є істиною

false && true || true // результат: true, оператор І має вищий пріорітет, тому обчислюємо false && true
//оператор І повертає істину, якщо обидва операнди істина, тому результат цього виразу є false
//розглянемо false || true, оператор логічне або повертає істину, якщо один з операндів істина, 
//тому результатом є перше істинне значення, яке зустрічається, результат - true

false && (true || true) //результат: false, спочатку обчислюємо вираз у дужках, бо він вищий за пріорітетом
//true || true, оператор логічне АБО повертає істину, якщо один з операндів істина, 
//тому результатом є перше істинне значення, яке зустрічається, результат - true
//false && true, оператор логічне І повертає перше хибне значення, яке зустрічається, результат false

(+null == false) < 1 ** 5 //результат: false, обчислюємо вираз у дужках (+null == false), 
//+null перетворює null на число 0, 0 == false дає результат true,
//обчислюємо далі за пріорітетом 1 в степені 5, вираз дорівнює 1
//true < 1, для обчислення перетворюється true на число 1, 1 < 1 не є істиною
*/